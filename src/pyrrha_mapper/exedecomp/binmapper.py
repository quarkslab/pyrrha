# -*- coding: utf-8 -*-

#  Copyright 2023-2025 Quarkslab
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""Filesystem mapper based on Lief, which computes imports and exports."""

import json
import logging
from collections import defaultdict, namedtuple
from dataclasses import dataclass
from pathlib import Path

from idascript import IDA
from numbat import SourcetrailDB

# third-party imports
from quokka import Function, Program
from quokka.types import FunctionType
from rich.progress import (
    BarColumn,
    MofNCompleteColumn,
    Progress,
    TextColumn,
    TimeElapsedColumn,
)

DECOMPILE_SCRIPT = Path(__file__).parent / "decompile.py"

once_check = True

Location = namedtuple("Location", "start_line start_col end_line end_col")


@dataclass
class DecompiledFunction:
    """Class used to represent a decompiled function."""

    address: int
    name: str  # demangled (pp_print)
    text: str
    location: Location  # location of the function name within text
    references: dict[
        int, list[Location]
    ]  # callee_addr -> list(start_line, start_col, end_line, end_col)
    numbat_id: int = -1


def is_new_numbat(db: SourcetrailDB) -> bool:
    """:return: True heck if a DB is generated by NumbatUI, False if it is by Sourcetrail."""
    global once_check
    if hasattr(db, "change_node_color"):  # check that attribute but could have been another one
        return True
    else:
        if once_check:
            logging.warning("Numbat does not support advanced features")
            once_check = False
        return False


def normalize_name(name: str) -> str:
    """Transform function name."""
    return name.strip("_").strip(".")


def find_all_call_references(
    f: Function, source: str, log_prefix: str = ""
) -> tuple[Location, dict[int, list[Location]]]:
    decl_loc = None
    refs = defaultdict(list)  # dict: call_addr -> list[Location]
    # ppname = lambda name: name.strip("_").strip(".")

    call_name_to_addr = {
        normalize_name(c.name): c.start for c in f.calls if c.name
    }  # NOTE: we exclude by design calls that
    call_addr_to_name = {
        c.start: normalize_name(c.name) for c in f.calls if c.name
    }  # don't have a name, usually these are calls
    # to unrecognized function e.g: loc_185CC
    for idx, line in enumerate(source.splitlines()):
        # try to find function declaration
        if decl_loc is None:
            ppname = normalize_name(f.name)
            col = line.find(normalize_name(f.name))
            if col != -1:
                decl_loc = Location(idx + 1, col + 1, idx + 1, col + len(ppname))

        # For a given line, this dict keeps the column (index) of all call matched
        matches: dict[int, tuple[int, str]] = {}

        # iterate each calls and try to find them in the line
        for cname, caddr in call_name_to_addr.items():
            col = line.find(f"{cname}(")
            if col != -1:
                matches[col] = (caddr, cname)

        # Iterate all matches in a sorted manner to avoid having overlap matches:
        # e.g: If a function calls both lxstat() and xstat() for each line we search
        # any occurence of this two functions. But if we have a line like: "int c = lxstats()"
        # we will match both functions! Thus we sort them by the column index. In that case we
        # keep lxstats().
        sorted_matches = sorted(list(matches.items()), key=lambda x: x[0])
        cursor = 0
        previous = (0, "")
        while sorted_matches:
            col, (caddr, cname) = sorted_matches.pop(0)
            if col < cursor:  # means the match is overlapping a previous match
                if col + len(cname) == cursor and previous[1].endswith(cname):
                    logging.debug(f"{log_prefix}: skip match {cname}, end of the {previous[1]}")
                else:
                    logging.warning(
                        f"{log_prefix}: skip match {cname} [col {col}] overlap with previous one  "
                        f"{previous[1]} [col: {previous[0]}]"
                    )
            else:  # its okay we add it
                refs[caddr].append(Location(idx + 1, col + 1, idx + 1, col + len(cname)))
                cursor = col + len(cname)
                previous = (col, cname)

    if decl_loc is None:
        logging.error(f"{log_prefix}: function declaration not found in source code")
    for ref in (x for x in call_addr_to_name if x not in refs):
        logging.error(
            f"{log_prefix}: call to {ref:#08x}:'{call_addr_to_name[ref]}' not found in source code"
        )

    return decl_loc, refs


def decompile_program(program: Program) -> Path:
    """Generate a PROGRAM_NAME.decompiled file which contained the binary decompilee obtained with IDA.

    :param program: Program object of the file to decompiled
    :return: path of the created decompiled file.
    """
    bin_path = program.executable.exec_file
    ida = IDA(bin_path, str(DECOMPILE_SCRIPT), [], timeout=180, exit_virtualenv=True)
    ida.start()
    ida.wait()
    return Path(str(bin_path) + ".decompiled")


def load_decompiled(program: Program, progress: Progress) -> dict[int, DecompiledFunction]:
    decompile_file = program.executable.exec_file.with_suffix(
        f"{program.executable.exec_file.suffix}.decompiled"
    )
    if decompile_file.exists():
        logging.info(f"load decompilation file: {decompile_file}")
        data = {int(k): v for k, v in json.loads(decompile_file.read_text()).items()}
        final_data = {}
        # Iterate the decompiled data to try make references inside
        decomp_load = progress.add_task("[deep_pink2]Decompiled binary loading", total=len(data))
        for f_addr, source_text in data.items():
            f = program[f_addr]

            decl, refs = find_all_call_references(
                f, source_text, log_prefix=f"[Decompiled binary loading] {f.name}"
            )

            final_data[f_addr] = DecompiledFunction(
                address=f_addr, name=f.name, text=source_text, location=decl, references=refs
            )
            progress.update(decomp_load, advance=1)

        return final_data
    else:
        logging.info("extracting decompilation file (with idascript)")
        decompile_file = decompile_program(program)
        if decompile_file.exists():
            return load_decompiled(program, progress)  # call ourselves again
        else:
            logging.warning("can't find decompilation file and idascript failed")
            return {}


def load_program(bin_path: Path) -> Program:
    quokka_file = Path(f"{bin_path}.quokka")
    if quokka_file.exists():
        logging.info("loading existing Quokka file")
        return Program(quokka_file, bin_path)
    else:  # Quokka file does not exists
        return Program.from_binary(bin_path, quokka_file)


def set_function_color(db: SourcetrailDB, p: Program, fun: Function, f_id: int) -> None:
    if is_new_numbat(db):  # Check that we have the capability
        # Change node color based on its type
        if is_thunk_to_import(p, fun):
            db.change_node_color(f_id, fill_color="#bee0af", border_color="#395f33")
        elif fun.type == FunctionType.THUNK:
            db.change_node_color(f_id, fill_color="gray")
        # elif fun.type == FunctionType.EXTERN:
        #     db.change_node_color(f_id, fill_color="magenta")
        # elif fun.type == FunctionType.IMPORTED:
        #     db.change_node_color(f_id, fill_color="mediumvioletred")
        else:
            pass  # Normal function let default color
    else:
        return


def add_source_file(
    db: SourcetrailDB,
    mangled_name: str,
    symbol_id: int,
    info: DecompiledFunction,
    log_prefix: str = "",
) -> bool:
    tmp = Path("/tmp/" + mangled_name)
    with open(tmp, "w") as f:
        f.write(info.text)

    # Record file
    file_id = db.record_file(Path(tmp))  # , indexed=False)
    if file_id is None:
        return False
    db.record_file_language(file_id, "cpp")
    tmp.unlink()  # QUESTION: Maybe we want to keep it for further analyses ?

    # Add the function to the file
    logging.debug(f"{log_prefix}: add function to file {file_id}")
    info.numbat_id = file_id
    # record de symbol declaration
    if info.location:
        l1, col1, l2, col2 = info.location
        db.record_symbol_location(symbol_id, file_id, l1, col1, l2, col2)
    else:
        logging.warning(f"{log_prefix}: declaration not found in source code")

    return True


def is_thunk_to_import(p: Program, f: Function) -> bool:
    if f.type == FunctionType.THUNK:
        if len(f.calls) == 1:
            c = f.calls[0]
            callee = p.get_function_by_chunk(c)[0]
            if callee.type in [FunctionType.EXTERN, FunctionType.IMPORTED]:
                return True
        return False
    else:
        return False


def map_binary(db: SourcetrailDB, program_path: Path) -> bool:
    # Load the Quokka file
    program = load_program(program_path)
    if program is None:
        logging.error("can't generate exported binary")
        return False

    with Progress(
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        MofNCompleteColumn(),
        TimeElapsedColumn(),
    ) as progress:
        # Load the decompilation file
        decompiled = load_decompiled(program, progress)
        if not decompiled:  # empty
            logging.error("failed to obtain decompiled code")
            return False

        # Index all the functions
        f_mapping = {}  # f_addr -> numbat_id
        func_map = progress.add_task("[orange_red1]Functions analysis", total=len(program))
        for f_addr, f in program.items():
            log_prefix = f"[Func analysis] {f.name} ({f.type})"
            if f.type in [FunctionType.EXTERN, FunctionType.IMPORTED]:
                logging.debug(f"{log_prefix}: extern function, skip")
                progress.update(func_map, advance=1)
                continue  # do not add EXTERN functions
            is_imp = is_thunk_to_import(program, f)
            f_id = db.record_function(
                f.name,
                parent_id=None,
                is_indexed=not is_imp,
            )  # , hover_display=f"{f.type.name.lower()} function")
            f_mapping[f_addr] = f_id

            if not is_imp:
                # Change node color based on its type
                set_function_color(db, program, f, f_id)

                # Add custom command to open that function in IDA
                abs_path = program.executable.exec_file.absolute()
                cmd = ["ida64", f"-ONumbatJump:{f_addr:#08x}", str(abs_path)]
                db.set_custom_command(f_id, cmd, "Open in IDA Pro")

                # Add source code if any
                if f_addr in decompiled:
                    info = decompiled[f_addr]
                    if not add_source_file(db, f.mangled_name, f_id, info):
                        logging.warning(f"{log_prefix}: failed to add decompiled code")

                else:
                    logging.warning(f"{log_prefix}: function not in decompiled dict")
            progress.update(func_map, advance=1)

        # Index the call graph
        cg_map = progress.add_task("[orange1]Call Graph Indexing", total=len(program))

        for f_addr, f in program.items():
            log_prefix = f"[Call Graph Indexing] {f.name}"
            decomp_fun = decompiled.get(f_addr, None)

            for callee in f.calls:
                try:
                    callee_id = f_mapping[callee.start]
                    ref_id = db.record_ref_call(f_mapping[f_addr], callee_id)  # record the call

                    if decomp_fun:  # if we have info about the decompiled function
                        if refs := decomp_fun.references.get(
                            callee.start
                        ):  # get the refs associated with callee
                            for li, coli, le, cole in refs:  # iterate them and add them
                                db.record_reference_location(
                                    ref_id, decomp_fun.numbat_id, li, coli, le, cole
                                )
                        else:
                            logging.debug(  # correspond to the previous error
                                f"{log_prefix}: calls {callee.name} but not references in DecompiledFunction"
                            )

                except KeyError:
                    pass  # ignore call to non recognized functions

            progress.update(cg_map, advance=1)
    return True
