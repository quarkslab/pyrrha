import logging
from collections import defaultdict
from contextlib import contextmanager
from pathlib import Path

# third-party imports
from numbat import SourcetrailDB
from rich.prompt import Prompt
from rich.progress import Progress, TextColumn, BarColumn, MofNCompleteColumn, TimeElapsedColumn

# local imports
from pyrrha_mapper import FileSystemMapper, FileSystem, Binary, Symbol, Symlink
from pyrrha_mapper.types import ResolveDuplicateOption
from pyrrha_mapper.intercg.loader import load_program

IGNORE_LIST = ["__gmon_start__"]

QUOKKA_EXT = ".quokka"

NUMBAT_UI_BIN = "numbat-ui"


@contextmanager
def hide(progress: Progress):
    """from https://github.com/Textualize/rich/issues/1535#issuecomment-1745297594"""
    transient = progress.live.transient # save the old value
    progress.live.transient = True
    progress.stop()
    progress.live.transient = transient # restore the old value
    try:
        yield
    finally:
        # make space for the progress to use so it doesn't overwrite any previous lines
        print("\n" * (len(progress.tasks) - 2))
        progress.start()


def load_file_system(fs: FileSystem) -> None:
    """
    This function takes a FileSystem object generated by FS-mapper and
    enrich it with InterCG-mapper required data. It includes call graphs
    and some function normalization in case collisions. It modifies the
    FileSystem object in place.

    :param fs: FileSystem object that will be enriched
    """

    tot = len(fs.binaries)

    for i, binary in enumerate(fs.iter_binaries()):
        quokka_file = binary.auxiliary_file(append=QUOKKA_EXT)
        s = "SKIP" if not binary.real_path.exists() else ("LOAD" if quokka_file.exists() else "CREATE")
        logging.info(f"[{i+1}/{tot}] process: {binary.name} [{s}]")
        if not binary.real_path.exists():
            logging.error(f"cannot find executable file mentioned in 'fs' mapper: {binary.real_path.name} (skip)")
            continue
        if binary.path.suffix == ".ko":  # ignore kernel modules at the moment
            logging.warning("do not map kernel modules at the moment (skip)")
            continue
        try:
            load_program(binary)
        except SyntaxError:
            logging.error(f"cannot load Quokka files: {quokka_file}")
            continue





class InterImageCGMapper(FileSystemMapper):
    """Filesystem mapper based on Lief, which computes imports and exports."""
    def __init__(self, root_directory: Path | str, fs_dump: FileSystem, db: SourcetrailDB | None):
        super(InterImageCGMapper, self).__init__(root_directory, db)
        # super initialize root_directory, db_interface, fs and _dry_run variables

        # override fs with the one provided by the fs_mapper (in dry-mode)
        # it should not contains any id
        self.fs = fs_dump

        if not self.dry_run_mode:
            # Change some headers
            self.db_interface.set_node_type("class", "Binaries", "binary")

        # Internal objects for fast lookup
        # self.binary_mapping: dict[int, Binary] = {}  # pyrrha_id -> Binary
        # self.pid_to_nid: dict[int, int] = {}  # pyrrha_id -> numbat_id
        # self.symbol_ids = {}  # (binary) numbat_id -> function name -> (symbol function) numbat_id

        # Mapping to keep Numbat ID to the associated object
        self.node_ids: dict[int, Binary | Symbol | Symlink] = {}
        # Mapping to keep export_name -> list[Binary] exposing this function
        self.exports_to_bins: dict[str, list[Binary]] = {}
        self.progress = None

    def load_binaries(self, cache_file: Path) -> None:
        """
        Load all the binaries located in the filesystem as Binary objects.

        :param root_path: root directory of the filesystem
        :param dump: Pyrrha dump
        :param cache_file: Cache file to load binaries from (if exists)
        :return: list of Binary objects
        """

        if cache_file.exists():
            logging.info(f"Load cached binaries: {cache_file.name}")
            self.fs = FileSystem.from_json_export(cache_file)

        else: # Otherwise load files from the filesystem
            load_file_system(self.fs)

            # Once finished stores the FS object (for fast reload)
            logging.debug(f"Store cached binaries: {cache_file}")
            self.fs.write(cache_file)

    def map(self, threads: int, resolver: ResolveDuplicateOption = ResolveDuplicateOption.IGNORE) -> FileSystem:
        # Step1: Load FileSystem object and enrich it if needed
        cache_file = self.db_interface.path.with_suffix(".bins.json")
        self.load_binaries(cache_file)

        # Then iterate all Binary objects to fill the database
        with Progress(
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            MofNCompleteColumn(),
            TimeElapsedColumn(),
        ) as progress:
            self.progress = progress  # need to be able to hide it further down in calls
            bins_count = len(self.fs.binaries)
            binaries_map = progress.add_task("[deep_pink2]Binaries mapping", total=bins_count)

            # ---------- Iterate all binaries and add Nodes in the database ---------
            for i, binary in enumerate(self.fs.iter_binaries()):
                logging.debug(f"[{i + 1}/{bins_count}] index node: {binary.name}")

                # Create the node entry in numbat and create the custom command
                self.add_binary_db(binary)
                self.add_custom_command(binary)

                # symbol_ids[bin_id] = {}

                # Add all functions within the binary as function of the binary
                for fun_symbol in binary.functions.values():
                    self.add_symbol_binary(binary, fun_symbol)

                # TODO: Removed for the moment
                # Iterate all exports to add additional (missing) export values in symbol_ids
                # for exp_name, canonical_target in binary.exports.items():
                #     # The export 'name' was not part of functions visible in IDA (so add it)
                #     if exp_name not in symbol_ids[bin_id]:
                #         n_id = symbol_ids[bin_id][canonical_target]
                #         symbol_ids[bin_id][exp_name] = n_id  # alias to the numbat_id

                progress.update(binaries_map, advance=1)
            # ---------------------------------------------------------------

            # Dict of:     exported-funs -> [binaries]
            self.exports_to_bins: dict[str, list[Binary]] = self.make_export_to_binaries_map()

            # Iterate again all binaries to create call edges (all numbat_id are created)
            cg_map = progress.add_task("[orange1]Call Graph mapping", total=bins_count)

            for i, binary in enumerate(self.fs.iter_binaries()):
                resolve_cache = set()
                logging.debug(f"-------------- [{i+1}/{bins_count}] index call graph {binary.path} --------------")

                # Filter symbols to solely the ones exposed by the imported libraries
                filtered_symbols = {}  # fun_name -> Symbol
                for lib in binary.imported_libraries.values():
                    # dep_num_id = pid_to_nid[dep_pyr_id]
                    # deps_symbols.update(symbol_ids[dep_num_id])
                    filtered_symbols.update(lib.exported_symbols)  # NOTE: Might silently overwrite a symbol

                count_res = {True: 0, False: 0}
                for f_name, targets in binary.calls.items():
                    fun_symbol: Symbol = binary.functions[f_name]
                    for target in targets:
                        try:
                            res = self._add_one_call(binary, fun_symbol, target, filtered_symbols, resolver, resolve_cache)
                            count_res[res] += 1
                        except KeyError as e:
                            logging.error(f"can't find symbols: {e}")

                # Log amount of symbols that succeeded
                good, bad = count_res[True], count_res[False]
                logging.debug(f"Good: {good}, Bad: {bad}")

                progress.update(cg_map, advance=1)

        # return the filesystem object
        return self.fs

    def add_binary_db(self, binary: Binary) -> None:
        """
        Add a binary into database. It will also set
        the newly created id into the object.

        :param binary: Binary to insert in database
        """
        bin_id = self.db_interface.record_class(str(binary.path))  # record the path
        binary.id = bin_id  # set the id to the object
        # pid_to_nid[binary.pyrrha_id] = bin_id  # fill pyrrha_id -> numbat_id
        # binary_mapping[binary.pyrrha_id] = binary  # fill index by pyrrha_id
        self.node_ids[bin_id] = binary

    def add_custom_command(self, binary: Binary) -> None:
        """
        Add a custom command to call numbat-ui on the underlying Sourcetrail.

        :param binary:
        :return:
        """
        cmd = ["NumbatUi", str(binary.real_path) + ".srctrlprj"]
        self.db_interface.set_custom_command(binary.id, cmd, "Open in NumbatUI")


    def add_symbol_binary(self, binary: Binary, symbol: Symbol) -> None:
        """
        Add a function symbol to the given binary.

        :param binary: Binary hosting the symbol
        :param symbol: Symbol to add to the binary
        """
        # register demangled name instead of mangled name
        f_id = self.db_interface.record_function(symbol.demangled_name, parent_id=binary.id)
        symbol.id = f_id
        # FIXME: To nodes with the same name will result in the same ID.
        # FIXME: Maybe shall be fixed at Numbat level ?
        # symbol_ids[bin_id][f_name] = f_id

        # If exported change its color
        if symbol.name in binary.exported_symbols:
            self.db_interface.change_node_color(
                f_id, fill_color="#bee0af", border_color="#395f33"
            )  # text_color="brown", icon_color="brown", hatching_color="#FFEBCD")

    def add_call_ref(self, src: Symbol, dst: Symbol) -> bool:
        """
        Add call reference between two symbols

        :param src: originator of the call
        :param dst: destination of the call
        """
        self.db_interface.record_ref_call(src.id, dst.id)
        return True

    def add_unindexed_call(self, src: Symbol, dst: str) -> None:
        """
        Add a call to an unindexed function. Namely add a new function node outside
        of any binary and add a call reference to it.

        :param src: source symbol
        :param dst: destination symbol
        """
        # NOTE: Add a node here which have no existence at Binary/Symbol level
        tgt_id = self.db_interface.record_function(dst, is_indexed=False)
        self.db_interface.record_ref_call(src.id, tgt_id)

    def make_export_to_binaries_map(self) -> dict[str, list[Binary]]:
        """
        Compute dict mapping: exported-funs -> binaries (exporting the function)
        Indeed multiple binaries can export the same symbol !
        """
        table = defaultdict(list)  # list there can be multiple symbols on the same address
        for binary in self.fs.iter_binaries():
            for export in binary.exports:
                table[export].append(binary)
        return table

    def _add_one_call(self, binary: Binary,
                      caller: Symbol,
                      callee: str,
                      deps_symbols: dict[str, Symbol],
                      resolver: ResolveDuplicateOption,
                      resolve_cache: set) -> bool:
        """
        Add call edge betwen caller and callee. The whole point of this function
        is to resolve the location of the target (callee) function. Namely finding
        the binary object where it lives.

        The cache enables resolving only different symbols imported from the
        same library. E.g: let's take sym1, sym2. We first resolve sym1 -> lib1.
        Then if we find out sym2 is also in lib1, then automatically consider it
        comes from there. The cache drastically reduces the number of interaction
        when using the interactive mode.

        :param binary: Binary object in which is the caller function
        :param caller: caller Symbol
        :param callee: callee function name as string
        :param resolver: resolution strategy enum
        :param resolve_cache: cache of resolved libs

        :return: True if target function was found
        """

        # local call
        if target := binary.functions.get(callee):
            return self.add_call_ref(caller, target)

        # call among libraries explicitely listed
        elif target := deps_symbols.get(callee):
            return self.add_call_ref(caller, target)

        # call not among libraries (need to find it)
        else:
            if target in IGNORE_LIST:
                return False

            # Get binaries exporting this symbol
            served_by: list[Binary] = self.exports_to_bins[callee]

            # if multiple binaries are exposing the symbol try discriminating the symbol
            if len(served_by) > 1:
                if choice := self.try_resolve_duplicate_symbols(binary, callee, served_by, resolver, resolve_cache):
                    # if a choice has been done
                    resolve_cache.add(choice)
                    served_by = [choice]

            # Check again
            if len(served_by) == 1:
                # Automatically add the lib to filtered_symbols
                new_lib = served_by[0]
                logging.debug(f"symbol {callee} served by {served_by[0].name} automatically add it!")
                deps_symbols.update(new_lib.exported_symbols)
                # Recursive call to try again with the newly added lib (should enter second case)
                return self._add_one_call(binary, caller, callee, deps_symbols, resolver, resolve_cache)

            else:  # still not resolved
                exposing: list[Binary] = self.exports_to_bins.get(callee, [])
                if exposing and len(exposing) > 1:
                    logging.warning(
                        f"{binary.path}: several matches for edge {caller} -> {callee}:"
                        f"{[x.name for x in exposing]}")
                else:
                    logging.debug(
                        f"{binary.path}: no match found for edge {caller} -> {callee}:"
                        f"{[x.name for x in exposing]}")
                    self.add_unindexed_call(caller, callee)
                return False


    def try_resolve_duplicate_symbols(self, binary: Binary,
                                      callee: str,
                                      candidates: list[Binary],
                                      resolver: ResolveDuplicateOption,
                                      resolve_cache: set[Binary]) -> Binary | None:
        """
        Try to discriminate the right destination of a call. This happens
        when two libraries are exposing the same symbol.

        :param binary: current binary
        :param callee: destination function
        :param candidates: list of Binary object exposing the symbol
        :param resolver: resolving strategy
        :param resolve_cache: cache of libs previously selected for that binary
        :return: user choice if any
        """
        assert len(candidates) > 1
        if resolver == ResolveDuplicateOption.IGNORE:
            return None
        elif resolver == ResolveDuplicateOption.INTERACTIVE:
            with hide(self.progress):
                print(f"cache: {[x.path for x in resolve_cache]}")
                for cache_entry in resolve_cache:
                    if cache_entry in served_by:  # reuse already selected entry
                        logging.debug(f"reuse manually selected entry to disambiguate {callee}")
                        served_by = [cache_entry]
                if len(served_by) > 1:  # still not resolved
                    print(f"symbol {callee} needed for {binary.path} served by multiple binaries:")
                    val = None
                    while val is None or val < 0 or val >= len(served_by):
                        for num, option in enumerate(self.exports_to_bins[callee]):
                            print(f"* [{num}] {option.path}")
                        res = Prompt.ask("Select (default=0): ")
                        try:
                            val = int(res) if res else 0
                        except ValueError:
                            print("Enter a valid number")
                    return self.exports_to_bins[callee][val]

        elif resolver == ResolveDuplicateOption.ARBITRARY:
            return self.exports_to_bins[callee][0]
