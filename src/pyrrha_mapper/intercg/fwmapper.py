"""InterCGMapper implementation."""

import logging
from collections import defaultdict
from contextlib import contextmanager
from pathlib import Path

# third-party imports
from numbat import SourcetrailDB
from rich.progress import (
    BarColumn,
    MofNCompleteColumn,
    Progress,
    TextColumn,
    TimeElapsedColumn,
)

# local imports
from pyrrha_mapper.common import Binary, FileSystem, FileSystemMapper, Symbol, Symlink
from pyrrha_mapper.intercg.loader import load_program
from pyrrha_mapper.types import ResolveDuplicateOption

IGNORE_LIST = ["__gmon_start__"]

QUOKKA_EXT = ".quokka"

NUMBAT_UI_BIN = "numbat-ui"


@contextmanager
def hide(progress: Progress):
    """From https://github.com/Textualize/rich/issues/1535#issuecomment-1745297594."""
    transient = progress.live.transient  # save the old value
    progress.live.transient = True
    progress.stop()
    progress.live.transient = transient  # restore the old value
    try:
        yield
    finally:
        # make space for the progress to use so it doesn't overwrite any previous lines
        print("\n" * (len(progress.tasks) - 2))
        progress.start()


class InterImageCGMapper(FileSystemMapper):
    """Filesystem mapper based on Lief, which computes imports and exports."""

    def __init__(
        self, root_directory: Path | str, fs_dump: FileSystem, db: SourcetrailDB | None
    ):
        super(InterImageCGMapper, self).__init__(root_directory, db)
        # super initialize root_directory, db_interface, fs and _dry_run variables

        # override fs with the one provided by the fs_mapper (in dry-mode)
        # it should not contains any id
        self.fs = fs_dump

        if not self.dry_run_mode and self.db_interface is not None:
            # Change some headers
            self.db_interface.set_node_type("class", "Binaries", "binary")

        # Internal objects for fast lookup
        # self.binary_mapping: dict[int, Binary] = {}  # pyrrha_id -> Binary
        # self.pid_to_nid: dict[int, int] = {}  # pyrrha_id -> numbat_id
        # self.symbol_ids = {}  # (binary) numbat_id -> function name -> (symbol function) numbat_id

        # Mapping to keep Numbat ID to the associated object
        self.node_ids: dict[int, Binary | Symbol | Symlink] = {}
        # Mapping to keep export_name -> list[Binary] exposing this function
        self.exports_to_bins: dict[str, list[Binary]] = {}
        self.progress: Progress | None = None
        self.unresolved_callgraph: dict[Binary, dict[Symbol, list[str]]] = dict()

    def load_file_system(self, fs: FileSystem) -> None:
        """Complete a FS object with data required by the InterCG-mapper.

        This function takes a FileSystem object generated by FS-mapper and
        enrich it with InterCG-mapper required data. It includes call graphs
        and some function normalization in case collisions. It modifies the
        FileSystem object in place.

        :param fs: FileSystem object that will be enriched
        """
        tot = len(fs.binaries)

        for i, binary in enumerate(fs.iter_binaries()):
            if binary.real_path is None:
                logging.error(
                    f"Path on the filesystem of the '{binary.name}' binary not set (skip)"
                )
                continue
            quokka_file = binary.auxiliary_file(append=QUOKKA_EXT)
            s = (
                "SKIP"
                if binary.real_path is None or not binary.real_path.exists()
                else ("LOAD" if quokka_file.exists() else "CREATE")
            )
            logging.info(f"[{i + 1}/{tot}] process: {binary.name} [{s}]")
            if not binary.real_path.exists():
                logging.error(
                    f"cannot find executable file mentioned in 'fs' mapper: \
    {binary.real_path.name} (skip)"
                )
                continue
            if binary.path.suffix == ".ko":  # ignore kernel modules at the moment
                logging.warning("do not map kernel modules at the moment (skip)")
                continue
            try:
                self.unresolved_callgraph[binary] = load_program(binary)
            except SyntaxError:
                logging.error(f"cannot load Quokka files: {quokka_file}")
                continue

    def load_binaries(self, cache_file: Path | None) -> None:
        """Load all the binaries located in the filesystem as Binary objects.

        :param root_path: root directory of the filesystem
        :param dump: Pyrrha dump
        :param cache_file: Cache file to load binaries from (if exists)
        :return: list of Binary objects
        """
        if cache_file is not None and cache_file.exists():
            logging.info(f"Load cached binaries: {cache_file.name}")
            self.fs = FileSystem.from_json_export(cache_file)

        else:  # Otherwise load files from the filesystem
            self.load_file_system(self.fs)

            if cache_file is not None:
                # Once finished stores the FS object (for fast reload)
                logging.debug(f"Store cached binaries: {cache_file}")
                self.fs.write(cache_file)

    def map(
        self,
        threads: int,
        resolution_strategy: ResolveDuplicateOption = ResolveDuplicateOption.IGNORE,
    ) -> FileSystem:
        # Step1: Load FileSystem object and enrich it if needed
        if self.dry_run_mode or self.db_interface is None:
            self.load_binaries(None)
        else:
            cache_file = self.db_interface.path.with_suffix(".bins.json")
            self.load_binaries(cache_file)

        # Then iterate all Binary objects to fill the database
        with Progress(
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            MofNCompleteColumn(),
            TimeElapsedColumn(),
        ) as progress:
            self.progress = progress  # need to be able to hide it further down in calls
            bins_count = len(self.fs.binaries)
            binaries_map = progress.add_task(
                "[deep_pink2]Binaries mapping", total=bins_count
            )

            # ---------- Iterate all binaries and add Nodes in the database ---------
            for i, binary in enumerate(self.fs.iter_binaries()):
                logging.debug(f"[{i + 1}/{bins_count}] index node: {binary.name}")

                # Create the node entry in numbat and create the custom command
                self.record_binary_in_db(binary)
                if binary.id is not None:
                    self.node_ids[binary.id] = binary
                    self._record_custom_command(binary)

                progress.update(binaries_map, advance=1)
            # ---------------------------------------------------------------

            # Dict of:     exported-funs -> [binaries]
            self.exports_to_bins = self.make_export_to_binaries_map()

            # Iterate again all binaries to create call edges (all numbat_id are created)
            cg_map = progress.add_task("[orange1]Call Graph mapping", total=bins_count)

            for i, binary in enumerate(self.fs.iter_binaries()):
                resolve_cache: set[Binary] = set()
                logging.debug(
                    f"-------------- [{i + 1}/{bins_count}] index call graph {binary.path} --------------"
                )

                # Filter symbols to solely the ones exposed by the imported libraries
                filtered_symbols: dict[str, Symbol] = {}  # fun_name -> Symbol
                for lib in binary.iter_imported_libraries():
                    # dep_num_id = pid_to_nid[dep_pyr_id]
                    # deps_symbols.update(symbol_ids[dep_num_id])
                    if lib is not None:
                        filtered_symbols.update(
                            lib.exported_symbols
                        )  # NOTE: Might silently overwrite a symbol

                count_res = {True: 0, False: 0}
                if binary in self.unresolved_callgraph:
                    for f_symb, targets in self.unresolved_callgraph[binary].items():
                        for target in targets:
                            try:
                                res = self._record_one_call(
                                    binary,
                                    f_symb,
                                    target,
                                    filtered_symbols,
                                    resolution_strategy,
                                    resolve_cache,
                                )
                                count_res[res] += 1
                            except KeyError as e:
                                logging.error(f"can't find symbols: {e}")

                # Log amount of symbols that succeeded
                good, bad = count_res[True], count_res[False]
                logging.debug(f"Good: {good}, Bad: {bad}")

                progress.update(cg_map, advance=1)

        # return the filesystem object
        return self.fs

    def _record_custom_command(self, binary: Binary) -> None:
        """Add a custom command to call numbat-ui on the underlying Sourcetrail.

        :param binary: binary on which to apply the custom command
        """
        if self.dry_run_mode or self.db_interface is None:
            return None
        cmd = ["NumbatUi", str(binary.real_path) + ".srctrlprj"]
        if binary.id is None:
            logging.warning(
                f"Cannot record command on binary {binary.name} as it has no id"
            )
        else:
            self.db_interface.set_custom_command(binary.id, cmd, "Open in NumbatUI")

    def _record_call_ref(self, src: Symbol, dst: Symbol) -> bool:
        """Add call reference between two symbols in DB.

        :param src: originator of the call
        :param dst: destination of the call
        """
        if self.dry_run_mode or self.db_interface is None:
            return False
        if src.id is None or dst.id is None:
            logging.error(
                f"Cannot record call ref between {src.name} and {dst.name}, both ids \
are not defined"
            )
            return False
        self.db_interface.record_ref_call(src.id, dst.id)
        return True

    def _record_unindexed_call(self, src: Symbol, dst: str) -> None:
        """Add a call to an unindexed function.

        Namely add a new function node outside of any binary and add a call reference
        to it.

        :param src: source symbol
        :param dst: destination symbol
        """
        if self.dry_run_mode or self.db_interface is None:
            return None
        # NOTE: Add a node here which have no existence at Binary/Symbol level
        tgt_id = self.db_interface.record_function(dst, is_indexed=False)
        if src.id is None or tgt_id is None:
            logging.error(
                f"Cannot record call ref between {src.name} and {dst}, both ids \
are not defined"
            )
            return None
        self.db_interface.record_ref_call(src.id, tgt_id)

    def make_export_to_binaries_map(self) -> dict[str, list[Binary]]:
        """Compute dict mapping: exported-funs -> binaries (exporting the function).

        Indeed multiple binaries can export the same symbol !
        """
        table = defaultdict(
            list
        )  # list there can be multiple symbols on the same address
        for binary in self.fs.iter_binaries():
            for export in binary.iter_exported_functions():
                table[export.name].append(binary)
        return table

    def _record_one_call(
        self,
        binary: Binary,
        caller: Symbol,
        callee: str,
        deps_symbols: dict[str, Symbol],
        resolver: ResolveDuplicateOption,
        resolve_cache: set,
    ) -> bool:
        """Record call edge betwen caller and callee.

        The whole point of this function is to resolve the location of the target
        (callee) function. Namely finding the binary object where it lives.

        The cache enables resolving only different symbols imported from the
        same library. E.g: let's take sym1, sym2. We first resolve sym1 -> lib1.
        Then if we find out sym2 is also in lib1, then automatically consider it
        comes from there. The cache drastically reduces the number of interaction
        when using the interactive mode.

        :param binary: Binary object in which is the caller function
        :param caller: caller Symbol
        :param callee: callee function name as string
        :param resolver: resolution strategy enum
        :param resolve_cache: cache of resolved libs

        :return: True if target function was found
        """
        # local call
        if binary.function_exists(callee):
            callee_symb = binary.get_function_by_name(callee)
            binary.add_call(caller, callee_symb)
            return self._record_call_ref(caller, callee_symb)

        # call among libraries explicitely listed
        elif target := deps_symbols.get(callee):
            binary.add_call(caller, target)
            return self._record_call_ref(caller, target)

        # call not among libraries (need to find it)
        if target in IGNORE_LIST:
            return False

        # Get binaries exporting this symbol
        served_by: list[Binary] = self.exports_to_bins[callee]

        # if multiple binaries are exposing the symbol try discriminating the symbol
        if len(served_by) > 1:
            if (
                resolver == ResolveDuplicateOption.INTERACTIVE
                and self.progress is not None
            ):
                with hide(self.progress):
                    choice = self._select_fs_component(
                        resolver, served_by, "[Calls resolution]", callee, resolve_cache
                    )
            else:
                choice = self._select_fs_component(
                resolver, served_by, "[Calls resolution]", callee, resolve_cache
            )
            if choice:
                # if a choice has been done
                resolve_cache.add(choice)
                served_by = [choice]

        # Check again
        if len(served_by) == 1:
            # Automatically add the lib to filtered_symbols
            new_lib = served_by[0]
            logging.debug(
                f"symbol {callee} served by {served_by[0].name} automatically add it!"
            )
            deps_symbols.update(new_lib.exported_symbols)
            # Recursive call to try again with the newly added lib (should enter second case)
            return self._record_one_call(
                binary, caller, callee, deps_symbols, resolver, resolve_cache
            )

        else:  # still not resolved
            exposing: list[Binary] = self.exports_to_bins.get(callee, [])
            if exposing and len(exposing) > 1:
                logging.warning(
                    f"{binary.path}: several matches for edge {caller} -> {callee}:"
                    f"{[x.name for x in exposing]}"
                )
            else:
                logging.debug(
                    f"{binary.path}: no match found for edge {caller} -> {callee}:"
                    f"{[x.name for x in exposing]}"
                )
                self._record_unindexed_call(caller, callee)
            return False
