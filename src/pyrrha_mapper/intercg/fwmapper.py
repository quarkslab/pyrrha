# -*- coding: utf-8 -*-

#  Copyright 2023-2025 Quarkslab
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""InterCGMapper implementation."""

import logging
from collections import defaultdict
from pathlib import Path
from typing import Any

# third-party imports
from numbat import SourcetrailDB
from rich.progress import Progress

# local imports
from pyrrha_mapper.common import (
    Binary,
    FileSystem,
    Symbol,
    Symlink,
    hide_progress,
)
from pyrrha_mapper.exceptions import FsMapperError
from pyrrha_mapper.fs import FileSystemImportsMapper
from pyrrha_mapper.intercg.loader import load_program
from pyrrha_mapper.types import ResolveDuplicateOption

IGNORE_LIST = ["__gmon_start__"]

QUOKKA_EXT = ".quokka"

NUMBAT_UI_BIN = "numbat-ui"


class InterImageCGMapper(FileSystemImportsMapper):
    """Filesystem mapper based on Lief, which computes imports and exports."""

    FS_EXT = ".fs.json"

    def __init__(self, root_directory: Path | str, db: SourcetrailDB | None):
        super(InterImageCGMapper, self).__init__(root_directory, db)
        # super initialize root_directory, db_interface, fs and _dry_run variables

        # override fs with the one provided by the fs_mapper (in dry-mode)
        # it should not contains any id

        if not self.dry_run_mode and self.db_interface is not None:
            # Change some headers
            self.db_interface.set_node_type("class", "Binaries", "binary")

        # Mapping to keep Numbat ID to the associated object
        self.node_ids: dict[int, Binary | Symbol | Symlink] = {}
        # Mapping to keep export_name -> list[Binary] exposing this function
        self.exports_to_bins: dict[str, list[Binary]] = {}
        self.progress: Progress | None = None
        self.unresolved_callgraph: dict[Path, dict[Symbol, list[str]]] = dict()

    def _correct_map_result(self, res: Any) -> bool:
        return (
            super()._correct_map_result(res)
            and len(res) == 2
            and isinstance(res[1], dict)
            and all(
                map(  # correct equivalent to `isinstance(data, dict[Symbol, list[str]])`
                    lambda x: isinstance(x[0], Symbol) and self._is_list_str(x[1]),
                    res[1].items(),
                )
            )
        )

    @staticmethod
    def load_binary(
        root_directory: Path,
        file_path: Path,
    ) -> tuple[Binary, dict[Symbol, list[str]] | None] | str:
        """Load all the binaries located in the filesystem as Binary objects.

        First check if a cache file exists, if yes, it will load all the binaries and
        their analysis from it.
        Otherwhise, it take a FileSystem object generated by FS-mapper and
        enrich it with InterCG-mapper required data. It includes call graphs
        and some function normalization in case collisions. It modifies the
        FileSystem object in place.

        :param cache_file: Cache file to load binaries from (if exists)
        """
        res = FileSystemImportsMapper.load_binary(root_directory, file_path)
        if isinstance(res, str):  # error message
            return res
        else:
            binary, _ = res
        if binary.real_path is None:
            return f"ERROR: Path on the filesystem of {binary.name} not set (skip)"
        if not binary.real_path.exists():
            return (
                f"ERROR cannot find executable mentioned in 'fs' mapper: "
                f"{binary.real_path.name} (skip)"
            )

        quokka_file = binary.auxiliary_file(append=QUOKKA_EXT)
        try:
            unresolved_cg = load_program(binary, f"[binary mapping] {binary.name}")
        except SyntaxError as e:
            logging.error(
                f"[binary mapping] {binary.name}: cannot load Quokka files {quokka_file}: {e}"
            )
            return (binary, None)
        except (FileNotFoundError, FsMapperError) as e:
            logging.error(f"[binary mapping] {binary.name}: error during file analysis: {e}")
            return (binary, None)
        return (binary, unresolved_cg)

    def map_binary(
        self,
        bin_object: Binary,
        additional_res: dict[Symbol, list[str]] | None = None,
    ) -> None:
        """Given a Binary object add it to the DB.

        This function updates the filesystem representation stored as `self.fs`.
        :param bin_object: Binary object
        """
        super().map_binary(bin_object)
        if additional_res is not None:
            self.unresolved_callgraph[bin_object.path] = additional_res
        if bin_object.id is not None:
            self.node_ids[bin_object.id] = bin_object
            if additional_res is not None:
                self._record_custom_command(bin_object, f"[bin mapping] {bin_object.name}")

    def _treat_bin_parsing_result(self, path: Path, res: Any):
        """Handle load_binary res, map it or display error."""
        log_prefix = f"[binary mapping] {path.name}"
        if isinstance(res, str):
            logging.error(f"{log_prefix}: {res}")
        elif self._correct_map_result(res):
            bin_obj, additional_info = res
            self.map_binary(bin_obj, additional_info)
        elif super()._correct_map_result(res):
            self.map_binary(res[0], None)
            logging.info(f"{log_prefix}: fallback to lief results, internal analysis failed")
        else:
            logging.warning(f"{log_prefix}: impossible to parse the following result {res}")

    def map_binaries_main(self, threads: int, progress: Progress) -> None:
        """Parse and map binaries of a given directory.

        Record them in self.fs and self.db (except if self.is_dry_run == True).
        :param threads: number of threads to use
        :param progress: a rich.progress bar object for cli rendering
        """
        if self.dry_run_mode or self.db_interface is None:
            cache_file = None
        else:
            cache_file = self.db_interface.path.with_suffix(self.FS_EXT)

        # if cache exists, load binaries from it and record them in DB
        if cache_file is not None and cache_file.exists():
            logging.info(f"[binary mapping]: Load cached binaries: {cache_file.name}")
            self.fs = FileSystem.from_json_export(cache_file)
            binaries_map = progress.add_task(
                "[red]Binaries recording", total=len(list(self.fs.iter_binaries()))
            )
            for binary in self.fs.iter_binaries():
                log_prefix = f"[bin mapping] {binary.name}"
                # Create the node entry in numbat and create the custom command
                self.record_binary_in_db(binary, log_prefix)
                if binary.id is not None:
                    self.node_ids[binary.id] = binary
                    self._record_custom_command(binary, log_prefix)

                progress.update(binaries_map, advance=1)
        else:
            super().map_binaries_main(threads, progress)

        if cache_file is not None:
            # Once finished stores the FS object (for fast reload)
            logging.info(f"[binary mapping]: Store cached binaries: {cache_file}")
            self.fs.write(cache_file)

    def mapper_main(
        self,
        threads: int,
        progress: Progress,
        resolution_strategy: ResolveDuplicateOption = ResolveDuplicateOption.IGNORE,
    ) -> FileSystem:
        """Main function of the mapper, return the result stored in a FileSytsem.

        :param threads: number of threads to use
        :param progress: a progress bar ready to be filled
        :param resolution_strategy: the chosen option for duplicate import resolution
        :return: The FileSystem object filled
        """  # noqa: D401
        # Step1: Load FileSystem object and enrich it if needed
        self.map_binaries_main(threads, progress)
        self.map_symlinks_main(progress)
        self.dry_run_mode = True  # (do not record lib imports in numbat db)
        self.map_lib_imports_main(progress, resolution_strategy)
        if self.db_interface is not None:
            self.dry_run_mode = False

        self.progress = progress  # need to be able to hide it further down in calls+

        # Dict of:     exported-funs -> [binaries]
        self.exports_to_bins = self.make_export_to_binaries_map()

        # Iterate again all binaries to create call edges (all numbat_id are created)
        cg_map = progress.add_task(
            "[gold1]Call Graph mapping", total=len(list(self.fs.iter_binaries()))
        )

        unindex_symbols: set[str] = set()
        for binary in self.fs.iter_binaries():
            log_prefix = f"[cg mapping] {binary.name}"
            count_res = {True: 0, False: 0}
            if binary.path in self.unresolved_callgraph:
                for f_symb, targets in self.unresolved_callgraph[binary.path].items():
                    if targets and not binary.function_exists(f_symb.name):
                        logging.error(
                            f"function {f_symb.name} ({hex(f_symb.addr) if f_symb.addr is not None else None}) not in binary: {binary.name}"
                        )
                        continue
                    for target in targets:
                        try:
                            res = self._record_one_call(
                                binary,
                                f_symb,
                                target,
                                resolution_strategy,
                                unindex_symbols,
                                log_prefix,
                            )
                            count_res[res] += 1
                        except KeyError as e:
                            logging.error(f"{log_prefix}: can't find symbols: {e}")

            # Log amount of symbols that succeeded
            good, bad = count_res[True], count_res[False]
            logging.debug(f"{log_prefix}: Good: {good}, Bad: {bad}")

            progress.update(cg_map, advance=1)

        if len(unindex_symbols) > 0:
            logging.warning(
                f"[cg mapping]: {len(unindex_symbols)}  symbols not resolved in userland binaries "
                f"(added as unindex symbols): {', '.join(sorted(list(unindex_symbols)))}"
            )

        # return the filesystem object
        return self.fs

    def _record_custom_command(self, binary: Binary, log_prefix: str = "") -> None:
        """Add a custom command to call numbat-ui on the underlying Sourcetrail.

        :param binary: binary on which to apply the custom command
        """
        if self.dry_run_mode:
            return None
        assert self.db_interface is not None
        cmd = ["NumbatUi", str(binary.real_path) + ".srctrlprj"]
        if binary.id is None:
            logging.warning(f"{log_prefix}: cannot record command as binary has no id")
        else:
            self.db_interface.set_custom_command(binary.id, cmd, "Open in NumbatUI")

    def _record_call_ref(self, src: Symbol, dst: Symbol, log_prefix: str = "") -> bool:
        """Add call reference between two symbols in DB.

        :param src: originator of the call
        :param dst: destination of the call
        """
        if self.dry_run_mode:
            return True
        assert self.db_interface is not None
        if src.id is None or dst.id is None:
            logging.error(
                f"{log_prefix}: Cannot record call ref between {src.name} and "
                f"{dst.name}, missing ids ({src.name}: {src.id}, {dst.name}: {dst.id})"
            )
            return False
        self.db_interface.record_ref_call(src.id, dst.id)
        return True

    def _record_unindexed_call(self, src: Symbol, dst: str, log_prefix: str = "") -> None:
        """Add a call to an unindexed function.

        Namely add a new function node outside of any binary and add a call reference
        to it.

        :param src: source symbol
        :param dst: destination symbol
        """
        if self.dry_run_mode:
            return None
        assert self.db_interface is not None
        # NOTE: Add a node here which have no existence at Binary/Symbol level
        tgt_id = self.db_interface.record_function(dst, is_indexed=False)
        if src.id is None or tgt_id is None:
            logging.error(
                f" {log_prefix}: Cannot record call ref between {src.name} and {dst}, "
                "both ids are not defined"
            )
            return None
        self.db_interface.record_ref_call(src.id, tgt_id)

    def make_export_to_binaries_map(self) -> dict[str, list[Binary]]:
        """Compute dict mapping: exported-funs -> binaries (exporting the function).

        Indeed multiple binaries can export the same symbol !
        """
        table = defaultdict(list)  # list there can be multiple symbols on the same address
        for binary in self.fs.iter_binaries():
            for export in binary.iter_exported_function_names():
                table[export].append(binary)
        return table

    def _record_one_call(
        self,
        binary: Binary,
        caller: Symbol,
        callee: str,
        resolver: ResolveDuplicateOption,
        unindex_symbols: set[str],
        log_prefix: str = "",
    ) -> bool:
        """Record call edge betwen caller and callee.

        The whole point of this function is to resolve the location of the target
        (callee) function. Namely finding the binary object where it lives.

        The cache enables resolving only different symbols imported from the
        same library. E.g: let's take sym1, sym2. We first resolve sym1 -> lib1.
        Then if we find out sym2 is also in lib1, then automatically consider it
        comes from there. The cache drastically reduces the number of interaction
        when using the interactive mode.

        :param binary: Binary object in which is the caller function
        :param caller: caller Symbol
        :param callee: callee function name as string
        :param resolver: resolution strategy enum

        :return: True if target function was found
        """
        # local call
        if binary.function_exists(callee):
            callee_symb = binary.get_function_by_name(callee)
            binary.add_call(caller, callee_symb)
            return self._record_call_ref(caller, callee_symb)

        if callee in IGNORE_LIST:
            return False

        # already solved import
        if binary.imported_symbol_exists(callee, is_resolved=True):
            callee_symb = binary.get_imported_symbol(callee)
            binary.add_call(caller, callee_symb)
            return self._record_call_ref(caller, callee_symb)

        # solve import from listed imported libraries
        tmp = self.resolve_symbol_import(binary, callee, resolver, log_prefix)
        if tmp is not None:
            target_bin, target_symb = tmp
            if not binary.imported_library_exists(target_bin.name):
                binary.add_imported_library(target_bin)
            binary.add_imported_symbol(target_symb)
            binary.add_call(caller, target_symb)
            return self._record_call_ref(caller, target_symb)

        # Get binaries exporting this symbol
        served_by: list[Binary] = self.exports_to_bins[callee]

        # if multiple binaries are exposing the symbol try discriminating the symbol
        if len(served_by) > 1:
            if resolver == ResolveDuplicateOption.INTERACTIVE and self.progress is not None:
                with hide_progress(self.progress):
                    choice = self._select_fs_component(resolver, served_by, log_prefix, callee)
            else:
                choice = self._select_fs_component(resolver, served_by, log_prefix, callee)
            if choice:
                # if a choice has been done
                served_by = [choice]  # registerded just below
            else:
                logging.warning(
                    f"{log_prefix}: several matches for edge {caller} -> {callee}:"
                    f"{[x.name for x in served_by]}"
                )
                return False
        if len(served_by) == 1:
            binary.add_imported_library(served_by[0])
            callee_symb = served_by[0].get_exported_symbol(callee)
            binary.add_imported_symbol(callee_symb)
            binary.add_call(caller, callee_symb)
            return self._record_call_ref(caller, callee_symb)
        else:  # still not resolved
            self._record_unindexed_call(caller, callee)
            if binary.path.suffix != ".ko":
                unindex_symbols.add(callee)
            logging.debug(f"{log_prefix}: no match found for edge {caller.name} -> {callee}")
            return False
