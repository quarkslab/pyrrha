# -*- coding: utf-8 -*-

#  Copyright 2023-2025 Quarkslab
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""InterCGMapper implementation."""

import logging
from collections import defaultdict
from pathlib import Path

# third-party imports
from numbat import SourcetrailDB
from rich.progress import Progress

# local imports
from pyrrha_mapper.common import (
    Binary,
    FileSystem,
    FileSystemMapper,
    Symbol,
    Symlink,
    hide_progress,
)
from pyrrha_mapper.intercg.loader import load_program
from pyrrha_mapper.types import ResolveDuplicateOption

IGNORE_LIST = ["__gmon_start__"]

QUOKKA_EXT = ".quokka"

NUMBAT_UI_BIN = "numbat-ui"

class InterImageCGMapper(FileSystemMapper):
    """Filesystem mapper based on Lief, which computes imports and exports."""

    def __init__(
        self, root_directory: Path | str, fs_dump: FileSystem, db: SourcetrailDB | None
    ):
        super(InterImageCGMapper, self).__init__(root_directory, db)
        # super initialize root_directory, db_interface, fs and _dry_run variables

        # override fs with the one provided by the fs_mapper (in dry-mode)
        # it should not contains any id
        self.fs = fs_dump

        if not self.dry_run_mode and self.db_interface is not None:
            # Change some headers
            self.db_interface.set_node_type("class", "Binaries", "binary")

        # Mapping to keep Numbat ID to the associated object
        self.node_ids: dict[int, Binary | Symbol | Symlink] = {}
        # Mapping to keep export_name -> list[Binary] exposing this function
        self.exports_to_bins: dict[str, list[Binary]] = {}
        self.progress: Progress | None = None
        self.unresolved_callgraph: dict[Path, dict[Symbol, list[str]]] = dict()

    def load_binaries(self, cache_file: Path | None) -> None:
        """Load all the binaries located in the filesystem as Binary objects.

        First check if a cache file exists, if yes, it will load all the binaries and
        their analysis from it.
        Otherwhise, it take a FileSystem object generated by FS-mapper and
        enrich it with InterCG-mapper required data. It includes call graphs
        and some function normalization in case collisions. It modifies the
        FileSystem object in place.

        :param cache_file: Cache file to load binaries from (if exists)
        """
        if cache_file is not None and cache_file.exists():
            logging.info(f"Load cached binaries: {cache_file.name}")
            self.fs = FileSystem.from_json_export(cache_file)
            return

        # Otherwise load files from the filesystem
        tot = len(self.fs.binaries)
        for i, binary in enumerate(self.fs.iter_binaries()):
            if binary.path.suffix == ".ko":  # ignore kernel modules at the moment
                logging.warning("do not map kernel modules at the moment (skip)")
                continue
            if binary.real_path is None:
                logging.error(
                    f"Path on the filesystem of '{binary.name}' binary not set (skip)"
                )
                continue
            if not binary.real_path.exists():
                logging.error(
                    f"cannot find executable file mentioned in 'fs' mapper: \
{binary.real_path.name} (skip)"
                )
                continue

            quokka_file = binary.auxiliary_file(append=QUOKKA_EXT)
            s = (
                "SKIP"
                if binary.real_path is None or not binary.real_path.exists()
                else ("LOAD" if quokka_file.exists() else "CREATE")
            )
            logging.info(f"[{i + 1}/{tot}] process: {binary.name} [{s}]")
            try:
                self.unresolved_callgraph[binary.path] = load_program(binary)
            except SyntaxError:
                logging.error(f"cannot load Quokka files: {quokka_file}")
                continue

        if cache_file is not None:
            # Once finished stores the FS object (for fast reload)
            logging.debug(f"Store cached binaries: {cache_file}")
            self.fs.write(cache_file)

    def mapper_main(
        self,
        threads: int,
        progress: Progress,
        resolution_strategy: ResolveDuplicateOption = ResolveDuplicateOption.IGNORE,
    ) -> FileSystem:
        """Main function of the mapper, return the result stored in a FileSytsem.

        :param threads: number of threads to use
        :param progress: a progress bar ready to be filled
        :param resolution_strategy: the chosen option for duplicate import resolution
        :return: The FileSystem object filled
        """  # noqa: D401
        # Step1: Load FileSystem object and enrich it if needed
        if self.dry_run_mode or self.db_interface is None:
            self.load_binaries(None)
        else:
            cache_file = self.db_interface.path.with_suffix(".bins.json")
            self.load_binaries(cache_file)

        self.progress = progress  # need to be able to hide it further down in calls
        bins_count = len(self.fs.binaries)
        binaries_map = progress.add_task(
            "[deep_pink2]Binaries mapping", total=bins_count
        )

        # ---------- Iterate all binaries and add Nodes in the database ---------
        for i, binary in enumerate(self.fs.iter_binaries()):
            logging.debug(f"[{i + 1}/{bins_count}] index node: {binary.name}")

            # Create the node entry in numbat and create the custom command
            self.record_binary_in_db(binary)
            if binary.id is not None:
                self.node_ids[binary.id] = binary
                self._record_custom_command(binary)

            progress.update(binaries_map, advance=1)
        # ---------------------------------------------------------------

        # Dict of:     exported-funs -> [binaries]
        self.exports_to_bins = self.make_export_to_binaries_map()

        # Iterate again all binaries to create call edges (all numbat_id are created)
        cg_map = progress.add_task("[orange1]Call Graph mapping", total=bins_count)

        for i, binary in enumerate(self.fs.iter_binaries()):
            resolve_cache: set[Binary] = set()
            logging.debug(
                f"-------------- [{i + 1}/{bins_count}] index call graph {binary.path} \
--------------"
            )

            # Filter symbols to solely the ones exposed by the imported libraries
            filtered_symbols: dict[str, Symbol] = {}  # fun_name -> Symbol
            for lib in binary.iter_imported_libraries():
                # dep_num_id = pid_to_nid[dep_pyr_id]
                # deps_symbols.update(symbol_ids[dep_num_id])
                if lib is not None:
                    filtered_symbols.update(
                        lib.exported_symbols
                    )  # NOTE: Might silently overwrite a symbol

            count_res = {True: 0, False: 0}
            if binary.path in self.unresolved_callgraph:
                for f_symb, targets in self.unresolved_callgraph[binary.path].items():
                    for target in targets:
                        try:
                            res = self._record_one_call(
                                binary,
                                f_symb,
                                target,
                                filtered_symbols,
                                resolution_strategy,
                                resolve_cache,
                            )
                            count_res[res] += 1
                        except KeyError as e:
                            logging.error(f"can't find symbols: {e}")

            # Log amount of symbols that succeeded
            good, bad = count_res[True], count_res[False]
            logging.debug(f"Good: {good}, Bad: {bad}")

            progress.update(cg_map, advance=1)

        # return the filesystem object
        return self.fs

    def _record_custom_command(self, binary: Binary) -> None:
        """Add a custom command to call numbat-ui on the underlying Sourcetrail.

        :param binary: binary on which to apply the custom command
        """
        if self.dry_run_mode or self.db_interface is None:
            return None
        cmd = ["NumbatUi", str(binary.real_path) + ".srctrlprj"]
        if binary.id is None:
            logging.warning(
                f"Cannot record command on binary {binary.name} as it has no id"
            )
        else:
            self.db_interface.set_custom_command(binary.id, cmd, "Open in NumbatUI")

    def _record_call_ref(self, src: Symbol, dst: Symbol) -> bool:
        """Add call reference between two symbols in DB.

        :param src: originator of the call
        :param dst: destination of the call
        """
        if self.dry_run_mode or self.db_interface is None:
            return False
        if src.id is None or dst.id is None:
            logging.error(
                f"Cannot record call ref between {src.name} and {dst.name}, missing ids\
 ({src.name}: {src.id}, {dst.name}: {dst.id})"
            )
            return False
        self.db_interface.record_ref_call(src.id, dst.id)
        return True

    def _record_unindexed_call(self, src: Symbol, dst: str) -> None:
        """Add a call to an unindexed function.

        Namely add a new function node outside of any binary and add a call reference
        to it.

        :param src: source symbol
        :param dst: destination symbol
        """
        if self.dry_run_mode or self.db_interface is None:
            return None
        # NOTE: Add a node here which have no existence at Binary/Symbol level
        tgt_id = self.db_interface.record_function(dst, is_indexed=False)
        if src.id is None or tgt_id is None:
            logging.error(
                f"Cannot record call ref between {src.name} and {dst}, both ids \
are not defined"
            )
            return None
        self.db_interface.record_ref_call(src.id, tgt_id)

    def make_export_to_binaries_map(self) -> dict[str, list[Binary]]:
        """Compute dict mapping: exported-funs -> binaries (exporting the function).

        Indeed multiple binaries can export the same symbol !
        """
        table = defaultdict(
            list
        )  # list there can be multiple symbols on the same address
        for binary in self.fs.iter_binaries():
            for export in binary.iter_exported_functions():
                table[export.name].append(binary)
        return table

    def _record_one_call(
        self,
        binary: Binary,
        caller: Symbol,
        callee: str,
        deps_symbols: dict[str, Symbol],
        resolver: ResolveDuplicateOption,
        resolve_cache: set,
    ) -> bool:
        """Record call edge betwen caller and callee.

        The whole point of this function is to resolve the location of the target
        (callee) function. Namely finding the binary object where it lives.

        The cache enables resolving only different symbols imported from the
        same library. E.g: let's take sym1, sym2. We first resolve sym1 -> lib1.
        Then if we find out sym2 is also in lib1, then automatically consider it
        comes from there. The cache drastically reduces the number of interaction
        when using the interactive mode.

        :param binary: Binary object in which is the caller function
        :param caller: caller Symbol
        :param callee: callee function name as string
        :param resolver: resolution strategy enum
        :param resolve_cache: cache of resolved libs

        :return: True if target function was found
        """
        # local call
        if binary.function_exists(callee):
            callee_symb = binary.get_function_by_name(callee)
            binary.add_call(caller, callee_symb)
            return self._record_call_ref(caller, callee_symb)

        # call among libraries explicitely listed
        elif target := deps_symbols.get(callee):
            binary.add_call(caller, target)
            return self._record_call_ref(caller, target)

        # call not among libraries (need to find it)
        if target in IGNORE_LIST:
            return False

        # Get binaries exporting this symbol
        served_by: list[Binary] = self.exports_to_bins[callee]

        # if multiple binaries are exposing the symbol try discriminating the symbol
        if len(served_by) > 1:
            if (
                resolver == ResolveDuplicateOption.INTERACTIVE
                and self.progress is not None
            ):
                with hide_progress(self.progress):
                    choice = self._select_fs_component(
                        resolver, served_by, "[Calls resolution]", callee, resolve_cache
                    )
            else:
                choice = self._select_fs_component(
                    resolver, served_by, "[Calls resolution]", callee, resolve_cache
                )
            if choice:
                # if a choice has been done
                resolve_cache.add(choice)
                served_by = [choice]

        # Check again
        if len(served_by) == 1:
            # Automatically add the lib to filtered_symbols
            new_lib = served_by[0]
            logging.debug(
                f"symbol {callee} served by {served_by[0].name} automatically add it!"
            )
            deps_symbols.update(new_lib.exported_symbols)
            # Recursive call to try again with the newly added lib (should enter second case)
            return self._record_one_call(
                binary, caller, callee, deps_symbols, resolver, resolve_cache
            )

        else:  # still not resolved
            exposing: list[Binary] = self.exports_to_bins.get(callee, [])
            if exposing and len(exposing) > 1:
                logging.warning(
                    f"{binary.path}: several matches for edge {caller} -> {callee}:"
                    f"{[x.name for x in exposing]}"
                )
            else:
                logging.debug(
                    f"{binary.path}: no match found for edge {caller} -> {callee}:"
                    f"{[x.name for x in exposing]}"
                )
                self._record_unindexed_call(caller, callee)
            return False
